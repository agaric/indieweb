<?php

/**
 * @file
 * IndieWeb functionality.
 */

use Drupal\comment\CommentInterface;
use Drupal\comment\Entity\CommentType;
use Drupal\Component\Utility\Unicode;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Url;
use Drupal\image\Entity\ImageStyle;
use Drupal\indieweb\Entity\FeedInterface;
use Drupal\indieweb\Entity\WebmentionInterface;
use Drupal\node\Entity\NodeType;
use Drupal\node\NodeInterface;
use Drupal\node\NodeTypeInterface;
use p3k\XRay;

define('WEBMENTION_QUEUE_NAME', 'indieweb_webmention');
define('POST_CONTEXT_QUEUE_NAME', 'indieweb_context');

/**
 * Implements hook_help().
 */
function indieweb_help($route_name, RouteMatchInterface $route_match) {

  $help = [
    'indieweb.admin.webmention_settings' => [
      'title' => 'Receiving webmentions',
      'text' => '<p>' . t('The easiest way to start receiving webmentions and pingbacks for any page is by using <a href="https://webmention.io/" target="_blank">https://webmention.io</a>. <br />You have to create an account by signing in with your domain. For more information how to sign in with your domain, see the <a href=":link_indieauth">IndieAuth</a> tab.<br />Webmention.io is open source so you can also host the service yourself.<br />You can also use the built-in webmention endpoint to receive webmentions.<br />All collected webmentions and pingbacks can be viewed on the <a href=":link_overview">overview page</a>.<br /><br /><strong>Blocks</strong><br />- Webmentions: show the likes and reposts of that url.<br />- Webmention notify form: let people submit a URL if the current page is mentioned there<br />- RSVP: shows people attending, interested etc. for an event<br />- Pingbacks: render all urls to site pinging back per page', [':link_indieauth' => Url::fromRoute('indieweb.admin.indieauth_settings')->toString(), ':link_overview' => Url::fromRoute('entity.webmention_entity.collection')->toString()]) . '</p>',
    ],
    'indieweb.admin.webmention_send_settings' => [
      'title' => 'Sending webmentions and syndicating content',
      'text' => '<p>' . t('The easiest way to syndicate content on social networks is by using <a href="https://brid.gy/" target="_blank">https://brid.gy</a>. <br />You have to create an account by signing in with your preferred social network. Bridgy is open source so you can also host the service yourself.<br /><br />Syndicating and sending webmentions can be done per node in the "Publish to" fieldset, which is protected with the "send webmentions" permission.<br />If no targets are configured, there is nothing to do. There is a syndication field on every node and comment type available to render your <a href=":syndication_link">syndications</a> for <a href="https://indieweb.org/posse-post-discovery" target="_blank">POSSE-Post-Discovery</a>.<br />If comments are enabled, put those fields only on the microformat view mode. The comment itself is available on comment/indieweb/cid and it is this URL that will be used for sending webmentions.', [':syndication_link' => Url::fromRoute('indieweb.syndications_list')->toString()]) . '</p>',
    ],
    'indieweb.admin.comment_settings' => [
      'title' => 'Comments',
      'text' => t("When a webmention is saved and is of property 'in-reply-to', it is possible to create a comment if the target of the webmention has comments enabled.<br />You have to create an entity reference field on your comment type which points to a webmention. This module ships with a comment webmention storage field, so it's easy to add.<br />On the 'Manage display' page of the comment you can set the formatter of that entity reference field to 'Webmention'.<br />The webmention preprocess formats the text content using the 'restricted_html' content format which comes default in Drupal 8<br />Every comment is available also at comment/indieweb/cid so this URL can also be a target for a webmention. If a webmention is send to this target, a comment will be created on the node, with the target cid as the parent.<br />Also, last but not least, don't forget to set permissions to view webmentions."),
    ],
    'indieweb.admin.microformats_settings' => [
      'title' => 'Microformats',
      'text' => '<p>' . t('Microformats are extensions to HTML for marking up people, organizations, events, locations, blog posts, products, reviews, resumes, recipes etc. Sites use microformats to publish a standard API that is consumed and used by search engines, aggregators, and other tools. See <a href="https://indieweb.org/microformats" target="_blank">https://indieweb.org/microformats</a> for more info. You will want to enable this if you want to publish or want other sites and readers to parse your content. The module will add classes on content, images etc. You can also add it to the markup yourself. Also read <a href="https://brid.gy/about#microformats">https://brid.gy/about#microformats</a> for details how Bridgy decides what to publish if you are using that service.<br /><br />Your homepage (at least, other pages are fine too) should also contain a h-card entry. An author block can be configured in the blocks section. Example markup:<br /><div class="indieweb-highlight-code">&lt;div class="h-card"&gt;My name is &lt;a class="u-url p-name" rel="me" href="/"&gt;Your name&lt;/a&gt;&lt;/div&gt;</div>') . '</p>',
    ],
    'entity.indieweb_feed.collection' => [
      'title' => 'Feeds',
      'text' => t('<p>Generate feeds in Microformat 2 , Atom or jf2feed+json. Atom feeds are generated using https://granary.io/.<br />Because content can be nodes, comments etc, it isn\'t possible to use views. However, you can create multiple feeds which aggregate the content in a page and/or feed.<br />The feeds are controlled by the \'access content\' permission and all items in the HTML feed will be rendered with the \'Microformat\' view mode.</p><p>You will need feeds when:</p><ul><li>you use Bridgy: the service will look for html link headers with rel="feed" and use those pages to crawl so it knows to which content it needs to send webmentions to.</li><li>you want to allow IndieWeb readers (Monocle, Together, Indigenous) to subscribe to your content. These are alternate types which can either link to a page with microformat entries. It\'s advised to have an h-card on that page too as some parsers don\'t go to the homepage to fetch that content.</li></ul>'),
    ],
    'indieweb.admin.micropub_settings' => [
      'title' => 'Micropublishing',
      'text' => '<p>' . t("Allow posting to your site. Before you can post, you need to authenticate and enable the IndieAuth Authentication API.<br />See <a href=':link_indieauth'>IndieAuth</a> to configure. More information about micropub: see <a href='https://indieweb.org/Micropub' target='_blank'>https://indieweb.org/Micropub</a>.", [':link_indieauth' => Url::fromRoute('indieweb.admin.indieauth_settings')->toString()]) . '</p><p>' . t("A very good client to test is <a href='https://quill.p3k.io' target='_blank'>https://quill.p3k.io</a>. A full list is available at <a href='https://indieweb.org/Micropub/Clients'>https://indieweb.org/Micropub/Clients</a>.<br />Indigenous (iOS and Android) are also microsub readers.") . '</p><p>Even if you do not decide to use the micropub endpoint, this screen gives you a good overview what kind of content types and fields you can create which can be used for sending webmentions or read by microformat parsers.</p>',
    ],
    'indieweb.admin.microsub_settings' => [
      'title' => 'Readers',
      'text' => '<p>' . t('Microsub is an early draft of a spec that provides a standardized way for clients to consume and interact with feeds collected by a server. <a href="https://indieweb.org/Microsub#Clients" target="_blank">Readers</a> are Indigenous (iOS and Android), Monocle and Together (both web) and many others to come. Servers are Aperture, Ekster etc. See <a href="https://indieweb.org/Microsub#Servers" target="_blank">https://indieweb.org/Microsub#Servers</a>. This module allows you to expose a microsub header link which can either be the built-in microsub server or set to an external service.<br /><br />Want to follow Twitter in your reader? Checkout <a href="https://granary.io" target="_blank">https://granary.io</a>!') . '</p>',
    ],
    'indieweb.admin.microsub_channels' => [
      'title' => 'Channels and sources',
      'text' => '<p>Configure your channels and sources for the built-in Microsub server. In case the server is not enabled, no items will be fetched.',
    ],
    'indieweb.admin.indieauth_settings' => [
      'title' => 'IndieAuth',
      'text' => '<p>' . t('IndieAuth is a way to use your own domain name to sign in to websites. Indieauth.com is a hosted service that does this for you and also adds Authentication API. It works by linking your website to one or more authentication providers such as Twitter or Google (RelMeAuth), then entering your domain name in the login form on websites that support IndieAuth. Indielogin.com and Indieauth.com is open source so you can also host the service yourself.<br /><br />The easy way is to add rel="me" links on your homepage which point to your social media accounts and on each of those services adding a link back to your home page. An author block is available which allows you to add rel="me" links in the note textarea. They can even be hidden. e.g.<div class="indieweb-highlight-code">&lt;a href="https://twitter.com/swentel" target="_blank" title="Twitter" rel="me"&gt;&lt;/a&gt;</div><br />You can also use a PGP key if you don\'t want to use a third party service. See <a href="https://indieauth.com/setup" target="_blank">https://indieauth.com/setup</a> for full details.') . '</p><p>You can also use the built-in auth and token endpoints and authorize with a Drupal user.</p>',
    ],
    'indieweb.admin.context_settings' => [
      'title' => 'Post context',
      'text' => '<p>' . t('When you create a post with a link which is a reply, like, repost or bookmark of an external post, you can fetch content from that URL so you can render more context.<br />You can also enable fetching of contexts on microsub items when you use the built-in microsub server.<br /><br />To enable this feature for node types, go to the node type settings screen and select a link field. Then on the manage display pages, add the post context field to the display. For microsub items, you can configure this per source.<br />Note: post contexts only work right now if the site for which you want to get the context supports microformats.') . '</p>'
    ],
    'indieweb.admin.cache_settings' => [
      'title' => 'Media cache',
      'text' => '<p>' . t('When using the built-in webmention or microsub endpoint, a lot of file urls are stored to external images. If you enable the Imagecache external module, the files are downloaded so they are cached locally. Use even more caching power by installing the CDN module.') . '</p>'
    ],
    'indieweb.fediverse' => [
      'title' => 'Fediverse',
      'text' => 'Check the README file that comes with this module to know how to setup your site with the Fediverse via Bridgy fed.',
    ],
  ];

  if ($route_name == 'help.page.indieweb') {

    $output = '';
    foreach ($help as $item) {
      $output .= '<h3>' . $item['title'] . '</h3>';
      $output .= $item['text'];
    }

    return $output;
  }
  elseif (isset($help[$route_name])) {
    return $help[$route_name]['text'];
  }

}

/**
 * Implements hook_theme().
 */
function indieweb_theme() {
  return [
    'webmention' => [
      'variables' => [
        'show_summary' => NULL,
        'show_created' => NULL,
        'show_avatar' => FALSE,
        'replace_comment_user_picture' => FALSE,
        'property' => NULL,
        'author_photo' => NULL,
        'author_name' => NULL,
        'created' => NULL,
        'source' => NULL,
        'content_text' => NULL,
        'content_html' => NULL,
      ],
    ],
    'webmention_author_photo' => [
      'variables' => [
        'author_photo' => NULL,
        'author_name' => NULL,
      ],
    ],
    'indieweb_author' => [
      'variables' => [
        'image' => NULL,
        'note' => NULL,
        'name' => NULL,
        'domain' => NULL,
      ],
    ],
    'indieweb_post_context' => [
      'variables' => [
        'name' => NULL,
        'class' => NULL,
        'content' => NULL,
        'content_truncated' => NULL,
      ],
    ],
  ];
}

/**
 * Prepares variables for the webmention template.
 *
 * @param $variables
 */
function template_preprocess_webmention(&$variables) {
  $content = '';

  switch ($variables['property']) {
    case 'like-of':
      $interaction = t('Liked by');
      break;
    case 'repost-of':
      $interaction = t('Reposted by');
      break;
    case 'in-reply-to':
      $interaction = t('Reply by');
      $content = $variables['content_text'];
      break;
    case 'mention-of':
      $interaction = t('Mention by');
      $content = $variables['content_text'];
      break;
    default:
      $interaction = t('Interaction from');
      break;
  }

  $variables['interaction'] = $interaction;

  if ($variables['show_created']) {
    $variables['created'] = \Drupal::service('date.formatter')->format($variables['created']);
  }

  if (!empty($content)) {
    $content = check_markup($content, 'restricted_html');
  }
  $variables['content'] = $content;
}

/**
 * Implements hook_page_attachments_alter().
 */
function indieweb_page_attachments_alter(array &$attachments) {

  // Add webmention and pingback rel links.
  $route = \Drupal::routeMatch()->getRouteObject();
  $is_admin = \Drupal::service('router.admin_context')->isAdminRoute($route);
  if (!$is_admin) {

    $config = \Drupal::config('indieweb.webmention');
    if ($config->get('webmention_expose_header_link')) {

      $endpoint = '';
      if ($config->get('webmention_internal')) {
        $endpoint = Url::fromRoute('indieweb.webmention.internal', [], ['absolute' => TRUE])->toString();
      }
      elseif ($config->get('webmention_notify')) {
        $endpoint = $config->get('webmention_endpoint');
      }

      if (!empty($endpoint)) {
        $link = [
          '#tag' => 'link',
          '#attributes' => [
            'rel' => 'webmention',
            'href' => $endpoint,
          ],
        ];
        $attachments['#attached']['html_head'][] = [$link, 'webmention'];
      }
    }

    if ($config->get('pingback_expose_header_link')) {

      $endpoint = '';
      if ($config->get('pingback_internal')) {
        $endpoint = Url::fromRoute('indieweb.pingback.internal', [], ['absolute' => TRUE])->toString();
      }
      elseif ($config->get('pingback_notify')) {
        $endpoint = $config->get('pingback_endpoint');
      }

      if (!empty($endpoint)) {
        $link = [
          '#tag' => 'link',
          '#attributes' => [
            'rel' => 'pingback',
            'href' => $endpoint,
          ],
        ];
        $attachments['#attached']['html_head'][] = [$link, 'pingback'];
      }
    }
  }

  if (\Drupal::service('path.matcher')->isFrontPage()) {

    // IndieAuth endpoints.
    if (($config = \Drupal::config('indieweb.indieauth')) && ($config->get('expose_endpoint_link'))) {

      if ($config->get('auth_internal')) {
        $authorization_endpoint = Url::fromRoute('indieweb.indieauth.auth_endpoint', [], ['absolute' => TRUE])->toString();
        $token_endpoint = Url::fromRoute('indieweb.indieauth.token_endpoint', [], ['absolute' => TRUE])->toString();
      }
      else {
        $authorization_endpoint = $config->get('authorization_endpoint');
        $token_endpoint = $config->get('token_endpoint');
      }

      $link = [
        '#tag' => 'link',
        '#attributes' => [
          'rel' => 'authorization_endpoint',
          'href' => $authorization_endpoint,
        ],
      ];
      $attachments['#attached']['html_head'][] = [
        $link,
        'authorization_endpoint',
      ];

      $link = [
        '#tag' => 'link',
        '#attributes' => [
          'rel' => 'token_endpoint',
          'href' => $token_endpoint,
        ],
      ];
      $attachments['#attached']['html_head'][] = [
        $link,
        'token_endpoint',
      ];
    }

    // Micropub.
    if (($config = \Drupal::config('indieweb.micropub')) && ($config->get('micropub_enable')) && $config->get('micropub_add_header_link')) {

      $link = [
        '#tag' => 'link',
        '#attributes' => [
          'rel' => 'micropub',
          'href' => Url::fromRoute('indieweb.micropub.endpoint', [], ['absolute' => TRUE])->toString(),
        ],
      ];

      $attachments['#attached']['html_head'][] = [
        $link,
        'micropub_endpoint',
      ];
    }

    // Microsub.
    if (($config = \Drupal::config('indieweb.microsub')) && $config->get('microsub_add_header_link')) {

      if ($config->get('microsub_internal')) {
        $endpoint = Url::fromRoute('indieweb.microsub.endpoint', [], ['absolute' => TRUE])->toString();
      }
      else {
        $endpoint = $config->get('microsub_endpoint');
      }

      $link = [
        '#tag' => 'link',
        '#attributes' => [
          'rel' => 'microsub',
          'href' => $endpoint,
        ],
      ];

      $attachments['#attached']['html_head'][] = [
        $link,
        'microsub_endpoint',
      ];
    }

    // Feeds.
    /** @var \Drupal\indieweb\Entity\FeedInterface $feed */
    foreach (\Drupal::entityTypeManager()->getStorage('indieweb_feed')->loadMultiple() as $feed) {
      if ($feed->exposeRelHeaderLink()) {
        $link = [
          '#tag' => 'link',
          '#attributes' => [
            'rel' => 'feed',
            'href' => Url::fromUri('internal:/' . $feed->getPath(), ['absolute' => TRUE])->toString(),
          ],
        ];

        $attachments['#attached']['html_head'][] = [
          $link,
          'feed_endpoint_' . $feed->id(),
        ];

      }

      if ($feed->exposeAtomFeed() && $feed->exposeAtomHeaderLink()) {
        $link = [
          '#tag' => 'link',
          '#attributes' => [
            'rel' => 'alternate',
            'type' => 'application/atom+xml',
            'href' => Url::fromUri('internal:/' . str_replace('/', '-', $feed->getPath()) . '.xml', ['absolute' => TRUE])
              ->toString(),
          ],
        ];

        $attachments['#attached']['html_head'][] = [
          $link,
          'feed_endpoint_atom_' . $feed->id(),
        ];
      }

      if ($feed->exposeJf2Feed() && $feed->exposeJf2HeaderLink()) {
        $link = [
          '#tag' => 'link',
          '#attributes' => [
            'rel' => 'alternate',
            'type' => 'application/jf2feed+json',
            'href' => Url::fromUri('internal:/' . str_replace('/', '-', $feed->getPath()) . '.jf2', ['absolute' => TRUE])->toString(),
          ],
        ];

        $attachments['#attached']['html_head'][] = [
          $link,
          'feed_endpoint_jf2_' . $feed->id(),
        ];

      }

    }
  }

}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for \Drupal\node\NodeForm.
 *
 * Adds post context fields to the node form.
 *
 * @see menu_ui_form_node_form_submit()
 */
function indieweb_form_node_type_form_alter(&$form, FormStateInterface $form_state) {

  $link_fields = [];
  $fields = \Drupal::service('entity_field.manager')->getFieldStorageDefinitions('node');
  $field_types = \Drupal::service('plugin.manager.field.field_type')->getDefinitions();

  /** @var \Drupal\Core\Field\FieldStorageDefinitionInterface $field */
  foreach ($fields as $key => $field) {
    if (in_array($field->getType(), ['link'])) {
      $link_fields[$key] = $field_types[$field->getType()]['label'] . ': ' . $field->getName();
    }
  }

  /** @var \Drupal\node\NodeTypeInterface $type */
  $type = $form_state->getFormObject()->getEntity();

  $default_link_field = $type->getThirdPartySetting('indieweb', 'post_context_link_field');
  $default_post_type = $type->getThirdPartySetting('indieweb', 'post_context_post_type');
  $form['indieweb'] = [
    '#type' => 'details',
    '#title' => t('IndieWeb settings'),
    '#group' => 'additional_settings',
    '#attached' => [
      'library' => ['indieweb/node-form'],
    ],
    '#attributes' => ['class' => ['indieweb-node-form']],
    '#description' => t('Select a link field, if available, which will be used to fetch content from.<br />On the Manage Display screens, you can select "Post context" field which will render context about this url.<br />Content will be fetched on creation of the node, or when the URL field is updated.'),
  ];

  $form['indieweb']['post_context_link_field'] = [
    '#type' => 'select',
    '#attributes' => ['class' => ['indieweb-post-context-field']],
    '#options' => ['' => t('Do not store external content')] + $link_fields,
    '#title' => t('Link field'),
    '#default_value' => $default_link_field,
  ];

  $form['indieweb']['post_context_post_type'] = [
    '#type' => 'select',
    '#options' => [
      'u-in-reply-to' => t('Reply'),
      'u-like-of' => t('Like'),
      'u-bookmark-of' => t('Bookmark'),
      'u-repost-of' => t('Repost'),
    ],
    '#title' => t('Post type'),
    '#description' => t('Select a type post field, for the right markup.'),
    '#default_value' => $default_post_type,
  ];

  $form['#entity_builders'][] = 'indieweb_node_type_builder';
}

/**
 * Entity form builder to add the post context information to the node.
 */
function indieweb_node_type_builder($entity_type, NodeTypeInterface $type, &$form, FormStateInterface $form_state) {
  $link_field = $form_state->getValue('post_context_link_field');
  $post_type = $form_state->getValue('post_context_post_type');
  if (!$link_field) {
    $post_type = '';
  }
  $type->setThirdPartySetting('indieweb', 'post_context_link_field', $link_field);
  $type->setThirdPartySetting('indieweb', 'post_context_post_type', $post_type);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function indieweb_form_user_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (_indieweb_user_authenticated_with_domain_on_edit_form()) {

    // Hide password fields as it's not needed. We also hide the current pass
    // so that the e-mail can be changed.
    $form['account']['pass']['#access'] = FALSE;
    $form['account']['current_pass']['#access'] = FALSE;

    // Set user_pass_reset in form_state. Users can always change their email
    // if wanted. The unique validation constraint will make sure they can not
    // set it to an existing email.
    $form_state->set('user_pass_reset', 1);
  }
}

/**
 * Checks if a user is authenticated with his domain on the user edit form.
 *
 * @return bool
 */
function _indieweb_user_authenticated_with_domain_on_edit_form() {
  $authenticated = FALSE;

  if (\Drupal::routeMatch()->getRouteName() == 'entity.user.edit_form' && ($account = \Drupal::routeMatch()->getParameter('user')) && \Drupal::currentUser()->id() == $account->id()) {
    // Check if login is enabled and current user is authenticated with domain
    // and has no administer users permission.
    if (\Drupal::config('indieweb.indieauth')->get('login_enable') && \Drupal::service('externalauth.authmap')->get($account->id(), 'indieweb') && !\Drupal::currentUser()->hasPermission('administer users')) {
      $authenticated = TRUE;
    }
  }

  return $authenticated;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for \Drupal\node\NodeForm.
 */
function indieweb_form_node_form_alter(&$form, FormStateInterface $form_state) {
  _indieweb_entity_form_alter($form, $form_state);
}

/**
 * Helper function to add IndieWeb publish to fieldsets.
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function _indieweb_entity_form_alter(&$form, FormStateInterface $form_state) {
  /** @var \Drupal\Core\Entity\EntityInterface $entity */
  $entity = $form_state->getFormObject()->getEntity();
  if ($entity) {
    $form['indieweb'] = [
      '#type' => 'details',
      '#title' => t('Publish to'),
      '#access' => \Drupal::currentUser()->hasPermission('send webmentions'),
      '#group' => 'advanced',
    ];

    $syndication_targets = indieweb_get_syndication_targets(TRUE);
    $form['indieweb']['indieweb_syndication_targets'] = [
      '#type' => 'checkboxes',
      '#options' => isset($syndication_targets['options']) ? $syndication_targets['options'] : [],
      '#default_value' => isset($syndication_targets['default']) ? $syndication_targets['default'] : [],
      '#access' => !empty($syndication_targets['options']),
    ];

    $options = [];
    $link_fields_string = \Drupal::config('indieweb.webmention')->get('send_link_fields');
    if (!empty($link_fields_string)) {
      $link_fields = explode('|', $link_fields_string);

      foreach ($link_fields as $field) {
        if ($entity->hasField($field)) {
          $options[$field] = t('Use @field', ['@field' => $field]);
        }
      }

      $form['indieweb']['indieweb_send_link_field'] = [
        '#title' => t('Link field'),
        '#type' => 'select',
        '#access' => !empty($options),
        '#options' => ['' => ''] + $options,
        '#description' => t('Use the link from a field on this content.'),
      ];
    }

    // Comment webmention.
    if ($entity->getEntityTypeId() == 'comment' && ($reference_field = \Drupal::config('indieweb.webmention')->get('send_comment_webmention_field')) && $entity->hasField($reference_field) && !empty($options)) {
      /** @var \Drupal\comment\CommentInterface $comment */
      $comment = $entity;

      if (\Drupal::config('indieweb.webmention')->get('send_comment_permission_fields')) {
        $form[$reference_field]['#access'] = \Drupal::currentUser()->hasPermission('send webmentions');

        foreach (array_keys($options) as $field_name) {
          $form[$field_name]['#access'] = \Drupal::currentUser()->hasPermission('send webmentions');
        }
      }

      // Default values for link fields on comment.
      if (($parent = $comment->getParentComment()) && $parent->hasField($reference_field) && \Drupal::currentUser()->hasPermission('send webmentions')) {
        /** @var \Drupal\indieweb\Entity\WebmentionInterface $webmention */
        $webmention = $parent->get($reference_field)->entity;
        if ($webmention && $webmention->get('url')->value) {
          foreach ($options as $key => $field) {
            $form[$key]['widget'][0]['uri']['#default_value'] = $webmention->get('url')->value;
          }
        }
      }
    }

    if (\Drupal::config('indieweb.webmention')->get('send_custom_url')) {
      $form['indieweb']['indieweb_send_custom_url'] = [
        '#type' => 'textfield',
        '#description' => t('Enter a custom URL'),
      ];
    }

    foreach (array_keys($form['actions']) as $action) {
      if ($action != 'preview' && isset($form['actions'][$action]['#type']) && $form['actions'][$action]['#type'] === 'submit') {
        $form['actions'][$action]['#submit'][] = '_indieweb_entity_content_form_submit';
      }
    }
  }

}

/**
 * Form submission handler for indieweb.
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *
 * @see indieweb_form_node_form_alter()
 *
 * @throws \Drupal\Core\Entity\EntityMalformedException
 */
function _indieweb_entity_content_form_submit($form, FormStateInterface $form_state) {
  /** @var \Drupal\Core\Entity\EntityInterface $entity */
  $entity = $form_state->getFormObject()->getEntity();
  if (method_exists($entity, 'isPublished') && $entity->isPublished()) {

    // Use our route for comments. Drupal core redirects to the entity, but we
    // need a page so webmentions can scan them for the content more easily.
    if ($entity->getEntityTypeId() == 'comment') {
      $source = Url::fromRoute('indieweb.comment.canonical', ['comment' => $entity->id()], ['absolute' => TRUE])->toString();
    }
    else {
      $source = $entity->toUrl()->setAbsolute(TRUE)->toString();
    }

    // Syndicate to.
    $syndicate_to = $form_state->getValue('indieweb_syndication_targets');
    if (!empty($syndicate_to)) {
      foreach ($syndicate_to as $key => $value) {
        if ($key === $value) {
          indieweb_webmention_create_queue_item($source, $key, $entity->id(), $entity->getEntityTypeId());
        }
      }
    }

    // Link fields.
    $link_field = $form_state->getValue('indieweb_send_link_field');
    if (!empty($link_field)) {
      if ($entity->hasField($link_field)) {
        $values = $entity->get($link_field)->getValue();
        if (!empty($values[0]['uri'])) {
          indieweb_webmention_create_queue_item($source, $values[0]['uri'], $entity->id(), $entity->getEntityTypeId());
        }
      }
    }

    // Custom URL.
    $custom_url = $form_state->getValue('indieweb_send_custom_url');
    if (!empty($custom_url)) {
      indieweb_webmention_create_queue_item($source, $custom_url, $entity->id(), $entity->getEntityTypeId());
    }

  }
}

/**
 * Implements hook_entity_insert().
 */
function indieweb_entity_insert(EntityInterface $entity) {
  indieweb_entity_update($entity, TRUE);
}

/**
 * Implements hook_entity_update().
 */
function indieweb_entity_update(EntityInterface $entity, $is_new = NULL) {
  if ($entity instanceof ContentEntityInterface) {
    try {
      _indieweb_entity_update_check_feeds($entity);
      _indieweb_entity_update_check_post_context($entity, $is_new);
    }
    catch (Exception $e) {
      \Drupal::logger('indieweb_entity')->notice('Error on entity action: @message', ['@message' => $e->getMessage()]);
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function indieweb_entity_delete(EntityInterface $entity) {

  if ($entity instanceof ContentEntityInterface) {

    // Delete from syndication table.
    \Drupal::database()
      ->delete('webmention_syndication')
      ->condition('entity_id', $entity->id())
      ->condition('entity_type_id', $entity->getEntityTypeId())
      ->execute();

    // Delete from feeds table.
    \Drupal::database()
      ->delete('indieweb_feed_item')
      ->condition('entity_id', $entity->id())
      ->condition('entity_type_id', $entity->getEntityTypeId())
      ->execute();

    // Delete from post_contexts table.
    \Drupal::database()
      ->delete('indieweb_post_context')
      ->condition('entity_id', $entity->id())
      ->condition('entity_type_id', $entity->getEntityTypeId())
      ->execute();
  }

  // Fix micropub config.
  if ($entity instanceof NodeTypeInterface) {
    $save = FALSE;
    $config = \Drupal::configFactory()->getEditable('indieweb.micropub');
    foreach (indieweb_micropub_post_types() as $post_type) {
      if ($config->get($post_type . '_node_type') == $entity->id()) {
        $save = TRUE;
        $config->set($post_type . '_node_type', '');
      }
    }

    if ($save) {
      $config->save();
    }
  }

}

/**
 * Update items for a feed.
 *
 * @param \Drupal\indieweb\Entity\FeedInterface $feed
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 * @throws \Exception
 */
function indieweb_update_feed_items(FeedInterface $feed) {
  \Drupal::database()
    ->delete('indieweb_feed_item')
    ->condition('feed', $feed->id())
    ->execute();

  foreach ($feed->getBundles() as $item) {
    list($entity_type, $bundle) = explode('|', $item);

    $entityType = \Drupal::entityTypeManager()->getDefinition($entity_type);
    $bundle_key = $entityType->getKey('bundle');

    $ids = \Drupal::entityQuery($entity_type)
      ->condition($bundle_key, $bundle)
      // TODO how safe is relying on created ?
      ->sort('created', 'DESC')
      ->condition('uid', $feed->getOwnerId())
      ->range(0, $feed->getLimit())
      ->execute();
    if (!empty($ids)) {
      foreach (\Drupal::entityTypeManager()->getStorage($entity_type)->loadMultiple($ids) as $entity) {
        _indieweb_entity_feed_insert($entity, $feed);
      }
    }
  }

  // Invalidate feed cache.
  Cache::invalidateTags(['indieweb_feed:' . $feed->id()]);
}

/**
 * Adds an entity to the feeds table, if necessary.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *
 * @throws \Exception
 */
function _indieweb_entity_update_check_feeds(EntityInterface $entity) {
  /** @var \Drupal\indieweb\Entity\FeedInterface $feed */
  foreach (\Drupal::entityTypeManager()->getStorage('indieweb_feed')->loadMultiple() as $feed) {
    if (in_array($entity->getEntityTypeId() . '|' . $entity->bundle(), $feed->getBundles())) {
      _indieweb_entity_feed_insert($entity, $feed);
      Cache::invalidateTags(['indieweb_feed:' . $feed->id()]);
    }
  }
}

/**
 * Adds an entity to the feeds table.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 * @param \Drupal\indieweb\Entity\FeedInterface|null $feed
 *
 * @throws \Exception
 */
function _indieweb_entity_feed_insert($entity, $feed) {
  // Assume yes if isPublished does not exist.
  $published = method_exists($entity, 'isPublished') ? $entity->isPublished() : 1;

  \Drupal::database()
    ->merge('indieweb_feed_item')
    ->key('entity_id', $entity->id())
    ->key('entity_type_id', $entity->getEntityTypeId())
    ->key('feed', $feed->id())
    ->fields([
      'published' => (int) $published,
      'timestamp' => $entity->getCreatedTime(),
    ])
    ->execute();
}

/**
 * Check if need to fetch a post context for an entity.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 * @param $is_new
 *
 * @throws \Exception
 */
function _indieweb_entity_update_check_post_context(EntityInterface $entity, $is_new) {

  // No need to check if it's not configured.
  $handler = \Drupal::config('indieweb.context')->get('handler');
  if (empty($handler) || $handler == 'disabled') {
    return;
  }

  // Check posts for node.
  if ($entity->getEntityTypeId() =='node') {

    $node_type = NodeType::load($entity->bundle());
    $link_field = $node_type->getThirdPartySetting('indieweb', 'post_context_link_field');

    if ($link_field && $entity->hasField($link_field)) {
      if ($url = $entity->get($link_field)->uri) {
        $create_queue_item = FALSE;
        if ($is_new) {
          $create_queue_item = TRUE;
        }
        elseif (isset($entity->original)) {
          $previous_url = $entity->original->get($link_field)->uri;
          if ($previous_url != $url) {
            $create_queue_item = TRUE;
          }
        }

        if ($create_queue_item) {
          indieweb_post_context_create_queue_item($url, $entity->id(), $entity->getEntityTypeId());
        }
      }
    }
  }
}

/**
 * Implements hook_preprocess_node().
 */
function indieweb_preprocess_node(&$variables) {
  if (in_array($variables['view_mode'], indieweb_microformat_view_modes())) {

    // Add h-entry or h-event.
    $h_entry = FALSE;
    if (\Drupal::config('indieweb.microformats')->get('h_entry')) {
      $h_entry = TRUE;
    }
    if (($h_event = \Drupal::config('indieweb.microformats')->get('h_event')) && $variables['node']->bundle() == $h_event) {
      $h_entry = FALSE;
      $variables['attributes']['class'][] = 'h-event';
    }
    if ($h_entry) {
      $variables['attributes']['class'][] = 'h-entry';
    }

    if (\Drupal::config('indieweb.microformats')->get('post_metadata')) {
      $date = \Drupal::service('date.formatter')->format($variables['node']->getCreatedTime(), 'custom', 'c');

      $exclude_p_name_node_type = \Drupal::config('indieweb.microformats')->get('p_name_exclude_node_type');
      if ($exclude_p_name_node_type && $variables['node']->bundle() == $exclude_p_name_node_type) {
        $metadata = '<span class="hidden">
          <a href="' . $variables['node']->toUrl('canonical', ['absolute' => TRUE])->toString() . '" class="u-url">
            <span class="dt-published">' . $date . '</span>
          </a>
          <a href="/" class="u-author"></a>
        </span>
        ';
      }
      else {
        $metadata = '<span class="hidden">
          <a href="' . $variables['node']->toUrl('canonical', ['absolute' => TRUE])->toString() . '" class="u-url">
            <span class="p-name">' . $variables['node']->getTitle() . '</span>
            <span class="dt-published">' . $date . '</span>
          </a>
          <a href="/" class="u-author"></a>
        </span>';
      }

      /**
       * Rdf module might have set the 'metadata' key.
       *
       * Depending whether a patch is applied, or is in core, we need to make
       * sure we don't crash and/or overwrite this key.
       *
       * @see rdf_preprocess_node().
       * @see https://www.drupal.org/project/drupal/issues/2819695
       */
      if (isset($variables['metadata'])) {
        $other = $variables['metadata'];
        $variables['metadata'] = [];
        // Patch applied, or core has been updated already.
        if (is_array($other)) {
          $variables['metadata']['other'] = $other;
          $variables['metadata']['indieweb'] = ['#markup' => $metadata];
        }
        // The metadata has been rendered.
        else {
          $variables['metadata']['#markup'] = $other;
          $variables['metadata']['indieweb'] = ['#markup' => $metadata];
        }
      }
      else {
        $variables['metadata'] = ['#markup' => $metadata];
      }
    }
  }

}

/**
 * Implements hook_preprocess_comment().
 */
function indieweb_preprocess_comment(&$variables) {

  // Replace comment user picture.
  if (isset($variables['content']['field_webmention'][0]['#replace_comment_user_picture']) && $variables['content']['field_webmention'][0]['#replace_comment_user_picture'] && !empty($variables['content']['field_webmention'][0]['#author_photo'])) {
    $variables['user_picture'] = [
      '#theme' => 'webmention_author_photo',
      '#author_photo' => $variables['content']['field_webmention'][0]['#author_photo'],
      '#author_name' => $variables['content']['field_webmention'][0]['#author_name'],
    ];
  }

  // Microformats for comments.
  if ($variables['elements']['#view_mode'] == 'indieweb_microformat') {

    // h-entry
    if (\Drupal::config('indieweb.microformats')->get('h_entry_comment')) {
      $variables['attributes']['class'][] = 'h-entry';
    }

    // Post metadata.
    if (\Drupal::config('indieweb.microformats')->get('post_metadata_comment')) {
      $date = \Drupal::service('date.formatter')
        ->format($variables['elements']['#comment']->getCreatedTime(), 'custom', 'c');

      $metadata = '<span class="hidden">
        <a href="' . $variables['elements']['#comment']->toUrl('canonical', ['absolute' => TRUE])->toString() . '" class="u-url">
          <span class="dt-published">' . $date . '</span>
        </a>
        <a href="/" class="u-author"></a>
      </span>';

      // Attach it to content.
      $variables['content']['indieweb_medata_data']['#markup'] = $metadata;
    }
  }
}

/**
 * Implements hook_preprocess_field().
 */
function indieweb_preprocess_field(&$variables) {

  $view_mode = isset($variables['element']['#view_mode']) ? $variables['element']['#view_mode'] : '';
  if (!empty($view_mode) && !in_array($view_mode, indieweb_microformat_view_modes())) {
    return;
  }

  // Put e-content on textarea fields.
  if ($variables['field_name'] == 'body' && \Drupal::config('indieweb.microformats')->get('e_content') || in_array($variables['field_name'], indieweb_get_content_fields())) {
    $variables['attributes']['class'][] = 'e-content';

    $exclude_p_name_node_type = \Drupal::config('indieweb.microformats')->get('p_name_exclude_node_type');
    if ($variables['element']['#object']->bundle() == $exclude_p_name_node_type) {
      $variables['attributes']['class'][] = 'p-name';
    }

    // Check p-bridgy-twitter-content class. In case there is no summary field
    // on this entity or the field is empty, then add it.
    if (\Drupal::config('indieweb.microformats')->get('p_bridgy_twitter_content')) {

      $add = TRUE;
      /** @var \Drupal\Core\Entity\EntityInterface $entity */
      $entity = $variables['element']['#object'];
      $summary_fields = indieweb_get_summary_fields();
      foreach ($summary_fields as $field) {
        if ($entity->hasField($field) && $entity->get($field)->getValue()) {
          $add = FALSE;
        }
      }

      if ($add) {
        $variables['attributes']['class'][] = 'p-bridgy-twitter-content';
      }
    }
  }

  // Put e-content on comment_body.
  if ($variables['field_name'] == 'comment_body' && \Drupal::config('indieweb.microformats')->get('e_content_comment')) {
    $variables['attributes']['class'][] = 'e-content';
  }

  // Date range fields.
  if ($h_event = \Drupal::config('indieweb.microformats')->get('h_event')) {
    if ($variables['element']['#field_type'] == 'daterange' && $variables['element']['#object']->bundle() == $h_event && !empty($variables['items'][0]['content'])) {
      foreach ($variables['items'] as $key => $item) {
        if (isset($item['content']['start_date'])) {
          $variables['items'][$key]['content']['start_date']['#attributes']['class'][] = 'dt-start';
        }
        if (isset($item['content']['end_date'])) {
          $variables['items'][$key]['content']['end_date']['#attributes']['class'][] = 'dt-end';
        }
      }
    }
  }

  // In case there's a p-summary.
  if (in_array($variables['field_name'], indieweb_get_summary_fields())) {
    $variables['attributes']['class'][] = 'p-summary';

    if (\Drupal::config('indieweb.microformats')->get('p_bridgy_twitter_content')) {
      $variables['attributes']['class'][] = 'p-bridgy-twitter-content';
    }
  }

}

/**
 * Implements hook_preprocess_image_style().
 *
 * @param $variables
 */
function indieweb_preprocess_image_style(&$variables) {
  if (\Drupal::config('indieweb.microformats')->get('u_photo')) {
    $variables['image']['#attributes']['class'][] = 'u-photo';
  }
}

/**
 * Implements hook_preprocess_file_audio().
 */
function indieweb_preprocess_file_audio(&$variables) {
  if (\Drupal::config('indieweb.microformats')->get('u_audio')) {
    if (!empty($variables['files'])) {
      foreach ($variables['files'] as $file) {
        $file['source_attributes']->addClass('u-audio');
      }
    }
  }
}

/**
 * Implements hook_preprocess_file_entity_audio().
 */
function indieweb_preprocess_file_entity_audio(&$variables) {
  if (\Drupal::config('indieweb.microformats')->get('u_audio')) {
    if (!empty($variables['files'])) {
      foreach ($variables['files'] as $file) {
        $file['source_attributes']->addClass('u-audio');
      }
    }
  }
}

/**
 * Implements hook_preprocess_file_video().
 */
function indieweb_preprocess_file_video(&$variables) {
  if (\Drupal::config('indieweb.microformats')->get('u_video')) {
    if (!empty($variables['files'])) {
      foreach ($variables['files'] as $file) {
        $file['source_attributes']->addClass('u-video');
      }
    }
  }
}

/**
 * Implements hook_preprocess_file_entity_video().
 */
function indieweb_preprocess_file_entity_video(&$variables) {
  if (\Drupal::config('indieweb.microformats')->get('u_video')) {
    if (!empty($variables['files'])) {
      foreach ($variables['files'] as $file) {
        $file['source_attributes']->addClass('u-video');
      }
    }
  }
}

/**
 * Implements hook_ds_pre_render_alter().
 */
function indieweb_ds_pre_render_alter(array &$layout_render_array, array $context, array &$variables) {
  if ($context['entity_type'] == 'node' && \Drupal::config('indieweb.microformats')->get('ds_node_support')) {
    $variables['view_mode'] = $context['view_mode'];
    indieweb_preprocess_node($variables);
  }
}

/**
 * Implements hook_entity_extra_field_info().
 */
function indieweb_entity_extra_field_info() {
  $extra = [];

  $syndication_targets = indieweb_get_syndication_targets();
  if (!empty($syndication_targets)) {

    // Fields for node.
    if (\Drupal::moduleHandler()->moduleExists('node')) {

      /** @var \Drupal\node\NodeTypeInterface $bundle */
      foreach (NodeType::loadMultiple() as $bundle) {
        foreach ($syndication_targets as $url => $name) {
          $machine_name = indieweb_get_machine_name_from_url($url);
          $extra['node'][$bundle->id()]['display'][$machine_name] = [
            'label' => $name,
            'weight' => 0,
            'visible' => FALSE,
          ];
        }

        // Syndication field.
        $extra['node'][$bundle->id()]['display']['indieweb_syndication'] = [
          'label' => t('Syndication'),
          'weight' => 0,
          'visible' => FALSE,
        ];

        // Post context field.
        $link_field = $bundle->getThirdPartySetting('indieweb', 'post_context_link_field');
        if ($link_field) {
          $extra['node'][$bundle->id()]['display']['indieweb_post_context'] = [
            'label' => t('Post context'),
            'weight' => 0,
            'visible' => FALSE,
          ];
        }

      }
    }

    // Fields for comment.
    if (\Drupal::moduleHandler()->moduleExists('comment')) {
      foreach (CommentType::loadMultiple() as $bundle) {
        foreach ($syndication_targets as $url => $name) {
          $machine_name = indieweb_get_machine_name_from_url($url);
          $extra['comment'][$bundle->id()]['display'][$machine_name] = [
            'label' => $name,
            'weight' => 0,
            'visible' => FALSE,
          ];
        }

        // Syndication field.
        $extra['comment'][$bundle->id()]['display']['indieweb_syndication'] = [
          'label' => t('Syndication'),
          'weight' => 0,
          'visible' => FALSE,
        ];
      }
    }

  }


  return $extra;
}

/**
 * Implements hook_ENTITY_TYPE_view() for node entities.
 */
function indieweb_node_view(array &$build, NodeInterface $node, EntityViewDisplayInterface $display) {
  _indieweb_extra_fields_display($build, $node, $display);
}

/**
 * Implements hook_ENTITY_TYPE_view() for comment entities.
 */
function indieweb_comment_view(array &$build, CommentInterface $comment, EntityViewDisplayInterface $display) {
  _indieweb_extra_fields_display($build, $comment, $display);
}

/**
 * Renders extra fields like targets and syndication.
 *
 * @param array $build
 * @param \Drupal\Core\Entity\EntityInterface $entity
 * @param \Drupal\Core\Entity\Display\EntityViewDisplayInterface $display
 */
function _indieweb_extra_fields_display(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display) {
  // Syndication targets fields.
  $syndication_targets = indieweb_get_syndication_targets();
  if (!empty($syndication_targets)) {
    $back_link = '';
    $add_back_link = \Drupal::config('indieweb.webmention')->get('bridgy_back_link');
    if ($add_back_link == 'never') {
      $back_link = ' class="p-bridgy-omit-link" value="true"';
    }
    elseif ($add_back_link == 'maybe') {
      $back_link = ' class="p-bridgy-omit-link" value="maybe"';
    }
    foreach ($syndication_targets as $url => $name) {
      $machine_name = indieweb_get_machine_name_from_url($url);
      if ($display->getComponent($machine_name)) {
        $build[$machine_name] = [
          '#markup' => '<span class="hidden"><a href="' . $url . '"'. $back_link .'></a></span>',
        ];
      }
    }
  }

  // Post context.
  if ($display->getComponent('indieweb_post_context')) {
    $node_type = NodeType::load($entity->bundle());
    $post_type_class = $node_type->getThirdPartySetting('indieweb', 'post_context_post_type');
    $suggestion = str_replace(['in-', '-to', '-of', 'u-'], '', $post_type_class);
    $contexts = indieweb_get_post_contexts($entity->id(), $entity->getEntityTypeId());
    foreach ($contexts as $context) {
      $text = isset($context['content']['content']->text) ? $context['content']['content']->text : '';
      $build['post_context'][] = [
        '#class' => $post_type_class,
        '#theme' => 'indieweb_post_context__' . $suggestion,
        '#content' => ['#markup' => nl2br($text)],
        '#content_truncated' => ['#markup' => Unicode::truncate(nl2br($text), 300, TRUE, TRUE)],
        '#name' => isset($context['content']['name']) ? $context['content']['name'] : '',
      ];
    }
  }

  // Syndication field.
  if ($display->getComponent('indieweb_syndication')) {
    $syndications = indieweb_get_syndications($entity->id(), $entity->getEntityTypeId());
    if ($syndications) {
      $items = [];

      foreach ($syndications as $url) {
        $items[] = [
          '#type' => 'link',
          '#url' => Url::fromUri($url),
          '#title' => $url,
          '#attributes' => ['class' => ['u-syndication']],
        ];
      }

      $build['indieweb_syndication'] = [
        '#theme' => 'item_list__indieweb_syndication',
        '#items' => $items,
        '#wrapper_attributes' => ['class' => ['indieweb-syndication-list']],
        '#title' => t('Syndications'),
      ];
    }
  }
}


/**
 * Implements hook_form_FORM_BASE_ID_alter() for the comments form.
 */
function indieweb_form_comment_form_alter(&$form, FormStateInterface $form_state) {
  _indieweb_entity_form_alter($form, $form_state);

  // Check the comment webmention reference field.
  $config = \Drupal::config('indieweb.comment');
  if ($config->get('comment_create_enable') && ($reference_field = $config->get('comment_create_webmention_reference_field'))) {
    if (isset($form[$reference_field]) && isset($form['comment_body'])) {
      /** @var \Drupal\comment\CommentInterface $comment */
      $comment = $form_state->getFormObject()->getEntity();
      // Deny access to comment form if webmention is referenced and body is
      // empty. Otherwise, you can not save this comment anymore.
      if (!$comment->isNew() && !empty($comment->get($reference_field)->target_id) && empty($comment->get('comment_body')->value)) {
        $form['comment_body']['#access'] = FALSE;
      }
    }
  }
}

/**
 * Implements hook_mail.
 *
 * @param $key
 * @param $message
 * @param $params
 */
function indieweb_mail($key, &$message, $params) {

  $options = array(
    'langcode' => $message['langcode'],
  );

  switch ($key) {
    case 'webmention_comment_created':
      /** @var \Drupal\comment\CommentInterface $comment */
      $comment = $params['comment'];
      $message['from'] = \Drupal::config('system.site')->get('mail');
      $message['subject'] = t('Comment created on "@title" via webmention', array('@title' => $comment->getCommentedEntity()->label()), $options);
      $message['body'][] = $params['comment_webmention_body'];
      if (!$comment->isPublished()) {
        $message['body'][] = "\n---------------------\n" . t('The comment is unpublished, so check the approval queue at @url', ['@url' => Url::fromRoute('comment.admin_approval', [], ['absolute' => TRUE])->toString()]);
      }
      break;
  }
}


/**
 * Implements hook_cron().
 */
function indieweb_cron() {

  if (\Drupal::config('indieweb.webmention')->get('send_webmention_handler') == 'cron') {
  // TODO move to service!
    indieweb_handle_webmention_queue();
  }

  if (\Drupal::config('indieweb.context')->get('handler') == 'cron') {
  // TODO move to service!
    indieweb_handle_post_context_queue();
  }

  if (\Drupal::config('indieweb.microsub')->get('microsub_internal') &&
    \Drupal::config('indieweb.microsub')->get('microsub_internal_handler') == 'cron') {
    \Drupal::service('indieweb.microsub.client')->fetchItems();
  }

  if (\Drupal::config('indieweb.webmention')->get('webmention_internal') &&
    \Drupal::config('indieweb.webmention')->get('webmention_internal_handler') == 'cron') {
    \Drupal::service('indieweb.webmention.client')->processWebmentions();
  }
}

/**
 * Get the syndications for an entity.
 *
 * @param $entity_id
 * @param $entity_type_id
 *
 * @return array
 */
function indieweb_get_syndications($entity_id, $entity_type_id) {
  $syndications = [];

  $records = \Drupal::database()->query('SELECT url FROM {webmention_syndication} WHERE entity_id = :entity_id AND entity_type_id = :entity_type_id', [':entity_id' => $entity_id, ':entity_type_id' => $entity_type_id]);
  foreach ($records as $record) {
    $syndications[] = $record->url;
  }

  return $syndications;
}

/**
 * Get the post contexts for an entity.
 *
 * @param $entity_id
 * @param $entity_type_id
 *
 * @return array
 */
function indieweb_get_post_contexts($entity_id, $entity_type_id) {
  $contexts = [];

  $records = \Drupal::database()->query('SELECT url, content FROM {indieweb_post_context} WHERE entity_id = :entity_id AND entity_type_id = :entity_type_id', [':entity_id' => $entity_id, ':entity_type_id' => $entity_type_id]);
  foreach ($records as $record) {

    $content = (array) json_decode($record->content);
    if (isset($content['post-type'])) {
      $contexts[] = [
        'url' => $record->url,
        'content' => $content,
      ];
    }

  }

  return $contexts;
}

/**
 * Returns the syndication targets.
 *
 * @param boolean $return_options_and_defaults
 *   Whether to return the syndication targets as an array with 'options' key
 *   and 'default' key.
 *
 * @return array
 */
function indieweb_get_syndication_targets($return_options_and_defaults = FALSE) {
  $syndication_targets = [];
  $config = \Drupal::config('indieweb.webmention')->get('syndication_targets');
  if (!empty($config)) {
    $lines = explode("\n", $config);
    foreach ($lines as $line) {
      $line = trim($line);
      if (!empty($line)) {
        $name_url = explode('|', $line);
        if (!empty($name_url[0]) && !empty($name_url[1])) {
          if ($return_options_and_defaults) {
            $syndication_targets['options'][$name_url[1]] = $name_url[0];
            if (isset($name_url[2]) && !empty($name_url[2]) && $name_url[2] == '1') {
              $syndication_targets['default'][] = $name_url[1];
            }
          }
          else {
            $syndication_targets[$name_url[1]] = $name_url[0];
          }
        }
      }
    }
  }

  return $syndication_targets;
}

/**
 * Creates a webmention queue item.
 *
 * @param $source
 * @param $target
 * @param $entity_id
 * @param $entity_type_id
 */
function indieweb_webmention_create_queue_item($source, $target, $entity_id = '', $entity_type_id = '') {
  $data = [
    'source' => $source,
    'target' => $target,
    'entity_id' => $entity_id,
    'entity_type_id' => $entity_type_id,
  ];

  // Bail out when target is one of the silos, but not actually the webmention
  // endpoint. This can happen with reply urls to twitter for example.
  if (indieweb_is_silo_url($target)) {
    return;
  }

  try {
    \Drupal::queue(WEBMENTION_QUEUE_NAME)->createItem($data);
  }
  catch (\Exception $e) {
    \Drupal::logger('indieweb_queue')->notice('Error creating queue item: @message', ['@message' => $e->getMessage()]);
  }
}

/**
 * Handles the webmention queue.
 */
function indieweb_handle_webmention_queue() {
  $end = time() + 15;
  $syndication_targets = indieweb_get_syndication_targets();
  while (time() < $end && ($item = \Drupal::queue(WEBMENTION_QUEUE_NAME)->claimItem())) {
    $data = $item->data;
    if (!empty($data['source']) && !empty($data['target'])) {

      try {

        $sourceURL = $data['source'];
        $targetURL = $data['target'];

        /** @var \Drupal\indieweb\WebmentionClient\WebmentionClientInterface $client */
        $client = \Drupal::service('indieweb.webmention.client');
        $response = $client->sendWebmention($sourceURL, $targetURL);

        // Store the syndication when the targetUrl is in the syndication
        // targets.
        if (isset($syndication_targets[$targetURL])) {
          if (!empty($response) && $response['code'] == 201 && !empty($response['headers']['Location'])) {

            if (!empty($data['entity_id']) && !empty($data['entity_type_id'])) {
              $values = [
                'entity_id' => $data['entity_id'],
                'entity_type_id' => $data['entity_type_id'],
                'url' => $response['headers']['Location'],
              ];

              \Drupal::database()
                ->insert('webmention_syndication')
                ->fields($values)
                ->execute();

              Cache::invalidateTags([$data['entity_type_id'] . ':' . $data['entity_id']]);
            }

            // Log the response if configured.
            if (\Drupal::config('indieweb.webmention')->get('send_log_response')) {
              \Drupal::logger('indieweb_send_response')->notice('response for @source to @target: @response', ['@response' => print_r($response, 1), '@source' => $sourceURL, '@target' => $targetURL]);
            }

          }
        }

      }
      catch (Exception $e) {
        \Drupal::logger('indieweb_publish')->notice('Error sending webmention for @source to @target: @message', ['@message' => $e->getMessage(), '@source' => $sourceURL, '@target' => $targetURL]);
      }
    }

    // Store in send table.
    $values = [
      'source' => $data['source'],
      'target' => $data['target'],
      'entity_id' => !empty($data['entity_id']) ? $data['entity_id'] : 0,
      'entity_type_id' => !empty($data['entity_type_id']) ? $data['entity_type_id'] : '',
      'created' => \Drupal::time()->getCurrentTime(),
    ];

    try {
      \Drupal::database()
        ->insert('webmention_send')
        ->fields($values)
        ->execute();
    }
    catch (\Exception $e) {
      \Drupal::logger('indieweb_publish')->notice('Error saving send webmention record: @message', ['@message' => $e->getMessage()]);
    }

    // Remove the item - always.
    \Drupal::queue(WEBMENTION_QUEUE_NAME)->deleteItem($item);
  }
}

/**
 * Handles the post context queue.
 */
function indieweb_handle_post_context_queue() {
  $end = time() + 15;
  $xray = new XRay();
  while (time() < $end && ($item = \Drupal::queue(POST_CONTEXT_QUEUE_NAME)->claimItem())) {
    $data = $item->data;
    if (!empty($data['url']) && !empty($data['entity_id']) && !empty($data['entity_type_id'])) {

      // Get content.
      // TODO we should make a helper service here, as microsub client does this
      // TODO make a service if from it as well
      // as well (in various ways :/)
      try {
        $response = \Drupal::httpClient()->get($data['url']);
        $body = $response->getBody()->getContents();

        $parsed = $xray->parse($data['url'], $body, ['expect'=>'feed']);
        if ($parsed && isset($parsed['data']['type']) && $parsed['data']['type'] == 'feed') {
            $reference = $parsed['data']['items'][0];

            // Nodes.
            if ($data['entity_type_id'] == 'node') {
              \Drupal::database()
                ->merge('indieweb_post_context')
                ->key('entity_id', $data['entity_id'])
                ->key('entity_type_id', $data['entity_type_id'])
                ->key('url', $data['url'])
                ->fields(['content' => json_encode($reference)])
                ->execute();
            }

            // Microsub.
            if ($data['entity_type_id'] == 'microsub_item') {
              \Drupal::database()
                ->merge('microsub_item')
                ->key('id', $data['entity_id'])
                ->fields(['post_context' => json_encode($reference)])
                ->execute();

          }
        }
      }
      catch (\Exception $e) {
        \Drupal::logger('indieweb_post_context')->notice('Error getting post context for @url: @message', ['@url' => $data['url'], '@message' => $e->getMessage()]);
      }
    }

    // Remove the item - always.
    \Drupal::queue(POST_CONTEXT_QUEUE_NAME)->deleteItem($item);
  }
}

/**
 * Creates a post context queue item.
 *
 * @param $url
 * @param $entity_id
 * @param $entity_type_id
 */
function indieweb_post_context_create_queue_item($url, $entity_id, $entity_type_id) {
  $data = [
    'url' => $url,
    'entity_id' => $entity_id,
    'entity_type_id' => $entity_type_id,
  ];

  try {
    \Drupal::queue(POST_CONTEXT_QUEUE_NAME)->createItem($data);
  }
  catch (\Exception $e) {
    \Drupal::logger('indieweb_queue')->notice('Error creating queue item: @message', ['@message' => $e->getMessage()]);
  }
}


/**
 * Sanitizes a url to use as a machine name.
 *
 * @param $url
 *
 * @return string
 */
function indieweb_get_machine_name_from_url($url) {
  return 'indieweb_' . str_replace(['https://', 'http://', '/', '-', '.'], '', $url);
}

/**
 * Get content fields for microformats.
 *
 * @return array
 */
function indieweb_get_content_fields() {
  static $fields = [];
  static $loaded = FALSE;

  if (!$loaded) {
    $loaded = TRUE;
    $fields = explode("\n", \Drupal::config('indieweb.microformats')->get('e_content_fields'));
  }

  return $fields;
}

/**
 * Get summary fields for microformats.
 *
 * @return array
 */
function indieweb_get_summary_fields() {
  static $fields = [];
  static $loaded = FALSE;

  if (!$loaded) {
    $loaded = TRUE;
    $fields = explode("\n", \Drupal::config('indieweb.microformats')->get('p_summary'));
  }

  return $fields;
}

/**
 * Checks if a source url already exists as syndication.
 *
 * This can happen when you reply from your site to twitter. Brid.gy will then
 * send that reply on twitter back as a webmention.
 *
 * @param \Drupal\indieweb\Entity\WebmentionInterface $webmention
 *
 * @return bool
 */
function indieweb_source_exists_as_syndication(WebmentionInterface $webmention) {
  $exists = FALSE;

  if (strpos($webmention->get('source')->value, 'brid-gy.appspot') !== FALSE) {
    $parts = parse_url($webmention->get('source')->value);
    $path_parts = explode('/', $parts['path']);
    if (!empty($path_parts[5])) {
      $exists = \Drupal::database()->query("SELECT count(url) as count FROM {webmention_syndication} WHERE url LIKE :id", [':id' => '%/' . db_like($path_parts[5])])->fetchField();
    }
  }

  return $exists;
}

/**
 * Checks whether the url is a silo URL or not. Currently detects Twitter urls.
 *
 * e.g. https://twitter.com/studioemma/status/999193968234713093 should be
 * marked as a silo url.
 *
 * @param $url
 *
 * @return bool
 */
function indieweb_is_silo_url($url) {
  $is_silo_url = FALSE;

  if (strpos($url, 'twitter.com') !== FALSE) {
    $is_silo_url = TRUE;
  }

  return $is_silo_url;
}

/**
 * Returns the view modes on which Microformats should be applied to.
 *
 * @return array
 */
function indieweb_microformat_view_modes() {
  return ['full', 'indieweb_microformat'];
}

/**
 * Returns the supported micropub post types.
 *
 * @return array
 */
function indieweb_micropub_post_types() {
  return ['article', 'note', 'like', 'reply', 'repost', 'bookmark', 'event', 'rsvp', 'issue'];
}

/**
 * Rewrites an image filename to use external imagecache if configured.
 *
 * @param $filename
 * @param $type
 *
 * @return string
 */
function indieweb_image_cache($filename, $type = 'avatar') {

  // Return early if the filename is empty.
  if (empty($filename)) {
    return $filename;
  }

  $cache = \Drupal::config('indieweb.cache');
  if ($cache->get('enable')) {

    // Ignore webmention io.
    if ($cache->get('ignore_webmention_io') && strpos($filename, 'webmention.io/avatar') !== FALSE) {
      return $filename;
    }

    // Imagecache external module.
    if ($cache->get('use_imagecache_external') && \Drupal::moduleHandler()->moduleExists('imagecache_external')) {
      $image_style = $cache->get('image_style_' . $type);
      $filename = imagecache_external_generate_path($filename);
      $style = ImageStyle::load($image_style);
      if ($style) {
        if ($style->supportsUri($filename)) {
          $filename = $style->buildUri($filename);
        }
      }
      $filename = file_create_url($filename);
    }
  }

  return $filename;
}

/**
 * Returns whether the imagecache is enabled or not.
 *
 * @return bool
 */
function indieweb_imagecache_enabled() {
  $cache = \Drupal::config('indieweb.cache');
  return $cache->get('enable') && $cache->get('use_imagecache_external');
}
